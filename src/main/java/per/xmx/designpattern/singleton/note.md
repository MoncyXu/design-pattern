# 单例模式
- 特点：
  - 单例类只有一个实例对象；
  - 该单例对象必须由单例类自行创建；
  - 单例类对外提供一个访问该单例的全局访问点；
- 通常适用的场景：
  - 在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。
  - 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。
  - 当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。
## 懒汉（懒加载）
这种方式是最基本的实现方式，不加锁的情况下存在线程安全的问题，加锁了又存在性能的问题。
## 饿汉（非懒加载、线程安全）
这种方式比较常用，但可能会产生垃圾对象。它基于 classloader 机制避免了多线程的同步问题。
## 双检锁（懒加载、线程安全）
这种方式采用双锁机制，安全且在多线程情况下能保持高性能，但是可用反射破解。
## 静态内部类（懒加载、线程安全）
这种方式效果和双检锁方式一样，而且比双检锁更容易实现。
## 枚举（非懒加载、线程安全）
实现单例的最佳方法，反射无法破解，更简洁，自动支持序列化机制，绝对防止多次实例化。
## 总结
一般情况下，不建议使用懒汉方式，建议使用饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用静态内部类方式。
如果涉及到反序列化创建对象时，可以尝试使用枚举方式。如果有其他特殊的需求，可以考虑使用双检锁方式。