# 代理模式
特点：
 - 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
应用场景：
 - 远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立
 一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。
 - 虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以
 先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。
 - 安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。
 - 智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以
 自动释放它。
 - 延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。
## 静态代理
静态代理模式在不改变目标对象的前提下，实现了对目标对象的功能扩展。
不足：静态代理实现了目标对象的所有方法，一旦目标接口增加方法，代理对象和目标对象都要进行相应的修改，增加维护成本。
## JDK动态代理
为解决静态代理对象必须实现接口的所有方法的问题，Java给出了动态代理，动态代理具有如下特点：
 - Proxy对象不需要implements接口；
 - Proxy对象的生成利用JDK的Api，在JVM内存中动态的构建Proxy对象。需要使用java.lang.reflect.Proxy类的newProxyInstance方法。该方法
   参数说明如下：
    - a.ClassLoader loader 原型对象的类加载器
    - b.Class<?>[] interfaces 原型对象实现的接口
    - c.InvocationHandler h 自定义事件处理器
## CGLIB动态代理
JDK动态代理要求target对象是一个接口的实现对象，假如target对象只是一个单独的对象，并没有实现任何接口，这时候就会用到Cglib代理
(Code Generation Library)，即通过构建一个子类对象，从而实现对target对象的代理，因此目标对象不能是final类(报错)，且目标对象的方法
不能是final或static（不执行代理功能）。